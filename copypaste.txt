I have one huge python file.  I want to break it up based on functionality and data source.  So it should primarily be Robinhood vs Yahoo.  Hereâ€™s my file from flask import Flask, render_template, request, jsonify, redirect, url_for
import os, requests
import pyotp
import pytz
import datetime
import yfinance as yf
import csv
from flask_cors import CORS
import sys

sys.path.insert(0, './robin_stocks')
import robin_stocks.robinhood as r

#Initialize Flask
app = Flask(__name__)
CORS(app)

#My Repl Secrets
username = os.environ['USERNAME']
password = os.environ['PASSWORD']
accessToken = os.environ['ACCESSTOKEN']

#MFA Authenticator
#Define Secret
totpSecret = os.environ['MFASECRET']
#Get Current time in EST
est = pytz.timezone('America/New_York')
currentTime = datetime.datetime.now(est)
#print("Currently it is: ", currentTime.strftime("%Y-%m-%d %H:%M:%S"))
#print(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

totp = pyotp.TOTP(totpSecret)
mfaCode = totp.at(currentTime)
print("MFA Code: ", mfaCode)


def getCode():
    currentTime = datetime.datetime.now(est)
    mfaCode = totp.at(currentTime)
    return (mfaCode)


#Login Function
def login():
    # Log in using the 2FA code sent to your device
    try:
        login = r.login(username=username,
                        password=password,
                        mfa_code=getCode())
        return (login)
    except Exception:
        return (print("Failed to Login"))


login()


@app.route('/quote/<symbol>', methods=['GET'])
def equityQuote(symbol):
    try:
        r.login(username=username, password=password, mfa_code=getCode())
        print("Logged in successfully")
        quote_data = r.stocks.get_fundamentals(symbol)
        print("Used Robin Stock API")
        return jsonify(quote_data)

    except Exception:

        oauth_token = accessToken

        if not symbol:
            return jsonify({"error": "Stock symbol is required"}), 400

        headers = {"Authorization": f"Bearer {oauth_token}"}

        url = f"https://api.robinhood.com/quotes/{symbol}/"

        try:
            # Make the API request directly with requests library
            response = requests.get(url, headers=headers)
            response.raise_for_status()  # Raise an error for bad status codes
            quote = response.json()
            print("Used Direct Request")
            return jsonify(quote)
        except requests.exceptions.HTTPError as err:
            return jsonify({"error": str(err)}), 500


headers = {"Authorization": f"Bearer {accessToken}"}

# Base URL for Robinhood API
base_url = "https://api.robinhood.com"


# Function to get the chain_id for a given stock symbol
def get_chain_id(symbol):
    url = f"{base_url}/instruments/"
    params = {"symbol": symbol}

    response = requests.get(url, headers=headers, params=params)
    response.raise_for_status()
    data = response.json()

    # Retrieve chain_id from the response
    if "results" in data and data["results"]:
        chain_id = data["results"][0]["id"]
        return chain_id
    else:
        print("Error: Could not find chain_id.")
        return None


# Function to get options contracts for a specific chain_id
def get_options_contracts(chain_id, expiration_date, option_type="call"):
    url = f"{base_url}/options/instruments/"
    params = {
        "chain_id": chain_id,
        "expiration_dates": expiration_date,
        "type": option_type
    }

    response = requests.get(url, headers=headers, params=params)
    response.raise_for_status()
    return response.json()


# Function to get market data for a specific options contract
def get_options_market_data(option_id):
    url = f"{base_url}/options/marketdata/{option_id}/"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    return response.json()


# Main function to fetch options data
def fetch_options_data(symbol, expiration_date, option_type="call"):
    # Step 1: Get the chain_id for the symbol
    chain_id = get_chain_id(symbol)
    if not chain_id:
        return {"error": "Failed to retrieve chain_id."}

    # Step 2: Get options contracts for the chain_id and expiration date
    contracts = get_options_contracts(chain_id, expiration_date, option_type)
    if "results" not in contracts or not contracts["results"]:
        return {"error": "No options contracts found."}

    # Step 3: Retrieve market data for each option contract
    options_data = []
    for contract in contracts["results"]:
        option_id = contract["id"]
        market_data = get_options_market_data(option_id)
        options_data.append({
            "option_id":
            option_id,
            "strike_price":
            contract["strike_price"],
            "expiration_date":
            contract["expiration_date"],
            "ask_price":
            market_data.get("ask_price"),
            "bid_price":
            market_data.get("bid_price"),
            "last_trade_price":
            market_data.get("last_trade_price")
        })

    return options_data


@app.route('/quote/options/<symbol>', methods=['GET'])
def quoteOptions(symbol):
    try:
        r.login(username=username, password=password, mfa_code=getCode())
        print("Logged in successfully")
        optionsData = r.options.find_tradable_options(symbol=symbol)
        print("Used Robin Stock API")
        return jsonify(optionsData)
    except Exception:
        return jsonify({"error": str("failed")}), 500


@app.route('/options/<symbol>', methods=['GET'])
def data(symbol):
    try:
        r.login(username=username, password=password, mfa_code=getCode())
        print("Logged in successfully")
        optionsData = r.options.find_tradable_options(symbol=symbol)
        print("Used Robin Stock API")
        expDates = {option["expiration_date"] for option in optionsData}
        expDates = sorted(expDates)
        print(expDates)
        #Get Unique Strikes
        strikes = {option["strike_price"] for option in optionsData}
        strikes = sorted(strikes)
        print(strikes)
        return jsonify(expDates)

    except Exception:
        return jsonify({"error": str("failed")}), 500


@app.route('/getoptionsdata/<symbol>', methods=['GET'])
def expDates(symbol):
    print("Getting data")
    try:
        ticker = yf.Ticker(symbol)
        exp = ticker.options
        optionsData = {}
        for e in exp:
            unix = int(datetime.datetime.strptime(e, '%Y-%m-%d').timestamp())
            #print(unix)
            option_chain = ticker._download_options(unix)
            #print(option_chain)
            #optionStrikes = {}
            optionsData[e] = []
            for option in option_chain['calls']:
                strike = option["strike"]
                if strike not in optionsData[e]:
                    optionsData[e].append(strike)
        return jsonify(optionsData)
    except Exception:
        return jsonify({"error": str("failed")}), 500


@app.route('/option/<symbol>/<exp>/<strike>/<porc>', methods=['GET'])
def optionsQuote(symbol, exp, strike, porc):
    # Generate the MFA code right before logging in
    mfaCode = pyotp.TOTP(totpSecret).now()
    logged_in = False  # Track login status
    try:
        # Log in with the generated MFA code
        login_data = r.login(username, password, mfa_code=getCode())

        # If login is successful, set logged_in to True
        if login_data:
            logged_in = True

        if porc == "P":
            porc = "put"
        if porc == "C":
            porc = "call"
        # Fetch options data based on the criteria
        options = r.options.find_options_by_expiration_and_strike(
            symbol, expirationDate=exp, strikePrice=strike, optionType=porc)

        if options:
            option_data = options[0]  # Assuming you want the first result
            last_trade_price = round(
                float(option_data.get("last_trade_price", 0)), 2)
            previous_close = round(
                float(option_data.get("previous_close_price", 0)), 2)
            bid_price = round(float(option_data.get("bid_price", 0)), 2)
            ask_price = round(float(option_data.get("ask_price", 0)), 2)

            volume = int(float(option_data.get("volume", 0)))

            # High and Low don't exist if no volume
            if volume == 0:
                high = 0
                low = 0
            else:
                high = round(float(option_data.get("high_price", 0)), 2)
                low = round(float(option_data.get("low_price", 0)), 2)

            bid_size = int(float(option_data.get("bid_size", 0)))
            ask_size = int(float(option_data.get("ask_size", 0)))

            volume = int(float(option_data.get("volume", 0)))

            if volume >= 1e7:
                formatted_volume = f"{int(volume // 1e6)}M{int((volume % 1e6) / 1e3)}k"
            elif volume >= 1e6:
                formatted_volume = f"{volume / 1e6:.1f}M"
            elif volume >= 1e3:
                formatted_volume = f"{volume / 1e3:.1f}k"
            else:
                formatted_volume = f"{volume}"

            if volume > 0:
                response = {
                    "description":
                    f"{'Up' if last_trade_price > previous_close else 'Down'} "
                    f"${abs(last_trade_price - previous_close):.2f} to ${last_trade_price:.2f}, "
                    f"high of ${high:.2f}, low of ${low:.2f}. "
                    f"Bid/Ask is {bid_price:.2f} by {ask_price:.2f}. "
                    f"Size is {bid_size} by {ask_size}. Volume is {formatted_volume}",
                    "raw_data": {
                        "quote": options
                    }
                }
            else:
                response = {
                    "description":
                    f"{'Up' if last_trade_price > previous_close else 'Down'} "
                    f"${abs(last_trade_price - previous_close):.2f} to ${last_trade_price:.2f}, "
                    f"No volume. "
                    f"Bid/Ask is {bid_price:.2f} by {ask_price:.2f}. "
                    f"Size is {bid_size} by {ask_size}.",
                    "raw_data": {
                        "quote": options
                    }
                }
            return jsonify(response)  # Return the option data as JSON
        else:
            # Handle case where no options were found
            print("No options found for the given criteria.")
            return jsonify(
                {"error": "No options found for the given criteria."}), 400

    except Exception as e:
        # Log and return any exceptions raised
        print("Error:", e)
        return jsonify({"error": str(e)}), 500
    finally:
        # Only logout if the login was successful
        if logged_in:
            r.logout()


# Route to get stock data
@app.route('/stockdata/<symbol>', methods=['GET'])
def get_stock_data(symbol):
    try:
        r.login(username=username, password=password, mfa_code=getCode())
        print("Logged in")
        quote = r.stocks.get_stock_quote_by_symbol(symbol)
        fundamentals = r.stocks.get_fundamentals(symbol)
        fundamentals = fundamentals[0]
        # Get latest from quote
        last_trade_price = round(float(quote.get("last_trade_price", 0)), 2)
        previous_close = round(float(quote.get("previous_close", 0)), 2)
        bid_price = round(float(quote.get("bid_price", 0)), 2)
        ask_price = round(float(quote.get("ask_price", 0)), 2)

        # Get latest from fundamentals
        high = round(float(fundamentals.get("high", 0)), 2)
        low = round(float(fundamentals.get("low", 0)), 2)

        bid_size = int(float(quote.get("bid_size", 0)))
        ask_size = int(float(quote.get("ask_size", 0)))

        volume = int(float(fundamentals.get("volume", 0)))

        if volume >= 1e7:
            formatted_volume = f"{int(volume // 1e6)}M{int((volume % 1e6) / 1e3)}k"
        elif volume >= 1e6:
            formatted_volume = f"{volume / 1e6:.1f}M"
        elif volume >= 1e3:
            formatted_volume = f"{volume / 1e3:.1f}k"
        else:
            formatted_volume = f"{volume}"

        response = {
            "description":
            f"{'Up' if last_trade_price > previous_close else 'Down'} "
            f"${abs(last_trade_price - previous_close):.2f} to ${last_trade_price:.2f}, "
            f"high of ${high:.2f}, low of ${low:.2f}.  "
            f"Bid/Ask is {bid_price:.2f} by {ask_price:.2f}. Size is {bid_size} by {ask_size}. Volume is {formatted_volume}",
            "raw_data": {
                "quote": quote,
                "fundamentals": fundamentals
            }
        }
        return jsonify(response)
    except Exception as e:
        try:
            try:
                # Get data for the commodity
                commodity = yf.Ticker(symbol)
                data = commodity.info

                bid = data.get('bid', None)
                bid_size = data.get('bidSize', None)
                ask = data.get('ask', None)
                ask_size = data.get('askSize', None)
                high = data.get('dayHigh', None)
                low = data.get('dayLow', None)
                previous_close = data.get('previousClose', None)
                volume = data.get('volume', None)

                # Determine the price to use
                if bid is not None and ask is not None:
                    mid_price = (bid + ask) / 2
                elif bid is not None:
                    mid_price = bid
                elif ask is not None:
                    mid_price = ask
                else:
                    mid_price = 'N/A'

                if mid_price == 'N/A' or previous_close is None:
                    response = {
                        "error":
                        "No valid price data available for the given symbol"
                    }
                else:
                    # Format volume with checks
                    if volume is not None:
                        if volume >= 1e7:
                            formatted_volume = f"{int(volume // 1e6)}M{int((volume % 1e6) / 1e3)}k"
                        elif volume >= 1e6:
                            formatted_volume = f"{volume / 1e6:.1f}M"
                        elif volume >= 1e3:
                            formatted_volume = f"{volume / 1e3:.1f}k"
                        else:
                            formatted_volume = str(volume)
                    else:
                        formatted_volume = 'N/A'

                    # Format response with checks for None values
                    response = {
                        "description":
                        f"{'Up' if mid_price > previous_close else 'Down'} "
                        f"${abs(mid_price - previous_close):.2f} to ${mid_price if mid_price != 'N/A' else 'N/A'}, "
                        f"high of ${high if high is not None else 'N/A'}, low of ${low if low is not None else 'N/A'}. "
                        f"Bid/Ask is {bid if bid is not None else 'N/A'} by {ask if ask is not None else 'N/A'}. "
                        f"Size is {bid_size if bid_size is not None else '100'} by {ask_size if ask_size is not None else '100'}. "
                        f"Volume is {formatted_volume}",
                        "raw_data": {
                            "current_price": mid_price,
                            "fundamentals": {
                                "high": data.get('dayHigh', 'N/A'),
                                "low": data.get('dayLow', 'N/A'),
                                "volume": data.get('volume', 'N/A'),
                                "open": data.get('open', 'N/A'),
                                "average_volume":
                                data.get('averageVolume', 'N/A')
                            },
                            "raw": data
                        }
                    }
                return jsonify(response)

            except Exception as e:
                return jsonify({"error": str(e)})
        except Exception:
            return jsonify({"error": str(e)}), 500


# New endpoint for commodities data using yfinance
@app.route('/commoditiesdata/<symbol>', methods=['GET'])
def get_commodities_data(symbol):
    try:
        # Get data for the commodity
        commodity = yf.Ticker(symbol)
        data = commodity.info

        bid = data.get('bid', None)
        bid_size = data.get('bidSize', None)
        ask = data.get('ask', None)
        ask_size = data.get('askSize', None)
        high = data.get('dayHigh', None)
        low = data.get('dayLow', None)
        previous_close = data.get('previousClose', None)
        volume = data.get('volume', None)

        # Determine the price to use
        if bid is not None and ask is not None:
            mid_price = (bid + ask) / 2
        elif bid is not None:
            mid_price = bid
        elif ask is not None:
            mid_price = ask
        else:
            mid_price = 'N/A'

        if mid_price == 'N/A' or previous_close is None:
            response = {
                "error": "No valid price data available for the given symbol"
            }
        else:
            # Format volume with checks
            if volume is not None:
                if volume >= 1e7:
                    formatted_volume = f"{int(volume // 1e6)}M{int((volume % 1e6) / 1e3)}k"
                elif volume >= 1e6:
                    formatted_volume = f"{volume / 1e6:.1f}M"
                elif volume >= 1e3:
                    formatted_volume = f"{volume / 1e3:.1f}k"
                else:
                    formatted_volume = str(volume)
            else:
                formatted_volume = 'N/A'

            # Format response with checks for None values
            response = {
                "description":
                f"{'Up' if mid_price > previous_close else 'Down'} "
                f"${abs(mid_price - previous_close):.2f} to ${mid_price if mid_price != 'N/A' else 'N/A'}, "
                f"high of ${high if high is not None else 'N/A'}, low of ${low if low is not None else 'N/A'}. "
                f"Bid/Ask is {bid if bid is not None else 'N/A'} by {ask if ask is not None else 'N/A'}. "
                f"Size is {bid_size if bid_size is not None else '100'} by {ask_size if ask_size is not None else '100'}. "
                f"Volume is {formatted_volume}",
                "raw_data": {
                    "current_price": mid_price,
                    "fundamentals": {
                        "high": data.get('dayHigh', 'N/A'),
                        "low": data.get('dayLow', 'N/A'),
                        "volume": data.get('volume', 'N/A'),
                        "open": data.get('open', 'N/A'),
                        "average_volume": data.get('averageVolume', 'N/A')
                    },
                    "raw": data
                }
            }
        return jsonify(response)

    except Exception as e:
        return jsonify({"error": str(e)})


@app.route('/shortcuts')
def shortcuts():
    equities, commodities = read_csv()
    return render_template("shortcuts.html",
                           equities=equities,
                           commodities=commodities)


# File path for the CSV file
shortcutsCSV = 'shortcuts.csv'


# Function to read and categorize data from CSV
def read_csv():
    equities = []
    commodities = []
    try:
        with open(shortcutsCSV, mode='r', newline='') as file:
            reader = csv.DictReader(file)
            for row in reader:
                # Classify as equity or commodity based on the presence of "=" in the symbol
                if '=' in row['symbol']:
                    commodities.append(row)
                else:
                    equities.append(row)
    except FileNotFoundError:
        pass
    return equities, commodities


# Function to write data to CSV
def write_csv(data):
    with open(shortcutsCSV, mode='w', newline='') as file:
        fieldnames = ["id", "title", "symbol"]
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for row in data:
            writer.writerow(row)


@app.route('/edit/<int:row_id>', methods=['POST'])
def edit(row_id):
    data = read_csv()
    for row in data:
        if row['id'] == row_id:
            row['title'] = request.form['title']
            row['symbol'] = request.form['symbol']
    write_csv(data)
    return redirect(url_for('index'))


@app.route('/delete/<int:row_id>', methods=['POST'])
def delete(row_id):
    data = read_csv()
    data = [row for row in data if row['id'] != row_id]
    write_csv(data)
    return redirect(url_for('index'))


@app.route('/add', methods=['POST'])
def add():
    equities, commodities = read_csv()
    data = equities + commodities
    # Filter out any None IDs just in case
    valid_ids = [int(row["id"]) for row in data if row["id"] is not None]
    new_id = max(
        valid_ids
    ) + 1 if valid_ids else 1  # Use max of valid IDs, or start at 1

    new_title = request.form['title']
    new_symbol = request.form['symbol']
    category = 'commodity' if '=' in new_symbol else 'equity'

    # Append the new item as a dictionary
    new_item = {"id": new_id, "title": new_title, "symbol": new_symbol}

    # Append and write back to CSV
    if category == 'commodity':
        commodities.append(new_item)
    else:
        equities.append(new_item)

    write_csv(equities + commodities)
    return redirect(url_for('index'))


@app.route('/')
def index():
    equities, commodities = read_csv()
    return render_template("index.html",
                           equities=equities,
                           commodities=commodities)


@app.route('/generate-otp/<secret>', methods=['GET'])
def generateOTP(secret):
    try:
        #Get Current time in EST
        timeNow = datetime.datetime.now(est)
        #print("Currently it is: ", timeNow.strftime("%Y-%m-%d %H:%M:%S"))
        #print(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        thetotp = pyotp.TOTP(secret)
        mfaCd = thetotp.at(timeNow)
        #print("MFA Code: ", mfaCd)
        return jsonify({'otp': mfaCd}), 200, {
            'ContentType': 'application/json'
        }
    except Exception as e:
        return jsonify({'error': str(e)}), 500


if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000, debug=True)
