javascript:(async()=>{const generateTOTP=async(secret=>{try{const now=new Date();console.log('Current Date and Time (Local):',now.toString());console.log('Current Date and Time (UTC):',now.toUTCString());const rawEpoch=Math.floor(now.getTime()/1000);console.log('Raw Epoch (UTC Seconds):',rawEpoch);const adjustedEpoch=rawEpoch-18000;console.log('Adjusted Epoch (EST):',adjustedEpoch);const time=Math.floor(adjustedEpoch/30);console.log('Time Step (TOTP Interval):',time);const crypto=window.crypto||window.msCrypto;const key=Uint8Array.from(atob(secret),c=>c.charCodeAt(0));console.log('Decoded Key:',key);const timeBytes=new Uint8Array(8);let tempTime=time;for(let index=7;index>=0;index--){timeBytes[index]=tempTime&0xff;tempTime>>=8;}console.log('Time Bytes:',timeBytes);const hmacKey=await crypto.subtle.importKey('raw',key,{name:'HMAC',hash:'SHA-1'},false,['sign']);const signature=new Uint8Array(await crypto.subtle.sign('HMAC',hmacKey,timeBytes));console.log('Signature (HMAC):',signature);const offset=signature[19]&0xf;console.log('Offset:',offset);const otp=((new DataView(signature.buffer).getUint32(offset)&0x7fffffff)%1000000).toString();console.log('Generated OTP:',otp);return otp.padStart(6,'0');}catch(error){console.error('Error in generateTOTP:',error.message);return undefined;}});const secret='YOUR_SECRET_BASE32';const otp=await generateTOTP(secret);if(otp){alert('Final OTP:'+otp);}else{alert('Failed to generate OTP.');}})();